import os
from flask import Flask, request, jsonify
from dotenv import load_dotenv
from langchain_community.embeddings import CohereEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_community.llms import Cohere
from langchain.chains import RetrievalQA
from langchain_community.document_loaders import PyPDFLoader
from langchain.text_splitter import CharacterTextSplitter

# Load environment variables from .env file
load_dotenv()

# Ensure your Cohere API key is set in your environment
COHERE_API_KEY = os.getenv("COHERE_API_KEY")
if not COHERE_API_KEY:
    raise ValueError("Please set the COHERE_API_KEY environment variable in your .env file.")

# Define the path to your PDF documents (relative to main.py)
pdf_dir = "docs"
documents = []

# Load all PDF files from the docs directory
for filename in os.listdir(pdf_dir):
    if filename.lower().endswith(".pdf"):
        pdf_path = os.path.join(pdf_dir, filename)
        loader = PyPDFLoader(pdf_path)
        docs_loaded = loader.load()
        documents.extend(docs_loaded)

if not documents:
    raise ValueError("No PDF documents found in the docs directory.")

# Optionally, split the loaded documents into smaller chunks for better retrieval
text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
docs = text_splitter.split_documents(documents)

# Create Cohere embeddings instance with the required model parameter and user_agent
embeddings = CohereEmbeddings(
    cohere_api_key=COHERE_API_KEY,
    model="embed-english-v2.0",  # Specify the embedding model from Cohere
    user_agent="my_rag_app"
)

# Set the path to save/load the FAISS vectorstore
faiss_index_path = "vectorstore/faiss_index"

# Ensure the vectorstore directory exists
if not os.path.exists("vectorstore"):
    os.makedirs("vectorstore")

# If an index already exists, load it (with dangerous deserialization allowed),
# otherwise create a new one and save it.
if os.path.exists(faiss_index_path):
    vectorstore = FAISS.load_local(faiss_index_path, embeddings, allow_dangerous_deserialization=True)
else:
    vectorstore = FAISS.from_documents(documents=docs, embedding=embeddings)
    vectorstore.save_local(faiss_index_path)

# Create a retriever from the vector store
retriever = vectorstore.as_retriever()

# Initialize the Cohere language model for generation
llm = Cohere(cohere_api_key=COHERE_API_KEY, model="command", max_tokens=100)

# Create a Retrieval QA chain using the retriever and language model
qa_chain = RetrievalQA.from_chain_type(llm=llm, chain_type="stuff", retriever=retriever)

# Set up the Flask app
app = Flask(__name__)

@app.route("/query", methods=["POST"])
def query():
    """
    Expects a JSON payload with a "query" field.
    Returns an answer generated by the retrieval QA chain.
    """
    data = request.get_json()
    query_text = data.get("query")
    if not query_text:
        return jsonify({"error": "No query provided."}), 400

    # Get the answer using the QA chain
    answer = qa_chain.run(query_text)
    return jsonify({"query": query_text, "answer": answer})

if __name__ == "__main__":
    # Run the Flask app on port 5000
    app.run(host="0.0.0.0", port=5000, debug=True)

